## Модули

Система модулей практически идентична языку Rust. Модули так же объявляются через `mod` в надмодулях. Доступ к модулям так же осуществляется через `::`, а через `use` можно импортировать символы в текущий скоуп.

В Flow есть несколько отличий:

### Модули могут быть названы с большой буквы и совпадать с именами объявленных в этом модуле типов, трейтов и эффектов

В частности это используется для того, чтобы связывать функции с типами для которых они реализуются
```rust
struct Pair<A, B> {
  first: A,
  second: B,
}

module Pair {
  fn new<A, B>(first: A, second: B) -> Pair<A, B> {
    Pair { first, second }
  }

  // метод, вызывается как pair.swap()
  fn <A, B>(pair: Pair<A, B>) swap() -> Pair<B, A> {
    Pair { first: pair.second, second: pair.first }
  }

  impl<A> Functor<<X> Pair<A, X>> {
    fn map<B, C>(pair: Pair<A, B>, f: fn(B) -> C) -> Pair<A, C> {
      Pair { first: pair.first, second: f(pair.second) }
    }
  }
}
```

Имена функций в модулях не могут совпадать с именами типов и трейтов в этом модуле

## Стейтменты

стейтменты разделены через `;`, если после последнего "стейтмента" в блоке нет `;`, то он является выражением и возвращает значение.

## Функции

Функции могут быть обычные, либо методы
```rust
// обычная функция
fn add(a: i32, b: i32) -> i32 {
  a + b
}

// инфиксная функция
fn (a: i32) add(b: i32) -> i32 {
  a + b
}

add(1, 2) // обычный вызов
1.add(2) // инфиксный вызов
```
В полиморфных по левому аргументу методах, полиморфность записывается перед параметром
```rust
fn <A>(a: A) wrap() -> Wrapper<A> {
  Wrapper { value: a }
}
```
В полиморфных по правому аргументу методах, полиморфность записывается после имени функции
```rust
fn (n: i32) times<A>(a: A) -> List<A> {
  List::repeat(n, a)
}

10.times("a") // ["a", "a", "a", "a", "a", "a", "a", "a", "a", "a"]
```

## Переменные

Переменные объявляются через `let`, такие переменные являются иммутабельными
```rust
let x = 10; // типизация выводится автоматически
let y: i32 = 20; // явное типирование
```

Мутабельные переменные объявляются через `let mut`
```rust
let mut x = 10;
x = 20;
```

Иммутабельные переменные могут быть объявлены на верхнем уровне в модулях и трейтах, но для них явно должен быть указан тип.

```rust
mod module {
  let x: i32 = 10;
}
```

## Трейты

Описаны в [Constraints.md](./Constraints.md)

## Эффекты

Описаны в [Effects.md](./Effects.md)

## Типы данных

Описаны в [Data types.md](./Data%20types.md)

## Условия

Условия заданы через `if` и `else`
```rust
if condition {
  // code
} else {
  // code
}
```
Условия являются выражениями и могут быть использованы в любом месте где допускается использование выражений.
```rust
let x = if condition1 {
  // code
} else if condition2 {
  // code
} else {
  // code
};
```

## Циклы

Циклы заданы через `for`, `while` и `loop`
```rust
for i in 0..10 {
  // code
}

while condition {
  // code
}

loop {
  // code
}
```

Лэйблы, break и continue так же доступны и выполнены как и в Rust.

## Матчинг

Матчинг задан через `match`
```rust
match value {
  // code
}

match value {
  pattern => ...
  pattern => ...
}

let x = Some(10)
match x {
  Some(x) if x > 10 => x, // guard
  Some(x) => x + 1,
  None => 0,
}
```
