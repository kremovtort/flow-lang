# Эффекты

Для контроля сайд эффектов и в качестве основного инструмента для инверсии контроля в Flow используются эффекты. Во Flow как языке программирования, фокус идёт на практическом применении эффектов, а не на теоретическом исследовании их возможностей. В связи с этим принимаются решения ниже.

## Какие эффекты поддерживаются

Существуют несколько способов категоризировать эффекты.

1. Первый способ категоризации эффектов:
  - algebraic effects
  - high-order effects:
    - scoped effects
    - parallel effects
    - latent effects

2. Второй способ:
  - single-shot
  - multi-shot

Приоритетна для Flow поддержка ((algebraic + scoped effects) * one-shot effects). Поддержка этого набора эффектов позволяет реализовать подавляющее большинство практически полезных эффектов. Так же она не требует дополнительных механизмов в рантайме для их поддержки, например, delimited continuations.

## Выбор хендлеров для эффектов

В различных языках программирования и библиотеках эффектов используются различные механизмы для выбора хендлеров для эффектов. Базово их можно разделить на два типа: динамический и лексический.

### Динамический выбор хендлеров

Динамический выбор хендлеров заключается в том, что хендлер выбирается в рантайме, в зависимости от контекста выполнения. Этот подход позволяет реализовать очень гибкие и мощные эффекты, но он также требует дополнительных механизмов в рантайме для их поддержки, например, delimited continuations.

### Лексический выбор хендлеров

Лексический выбор хендлеров заключается в том, что хендлер выбирается в лексическом контексте, в зависимости от контекста выполнения. Примерно это работает так: есть стек эффектов, и когда мы попадаем в область действия эффекта, мы выбираем ближайший хендлер соответствующего типа для этого эффекта из стека.

### Выбор хендлеров для эффектов в Flow

В Flow используется лексический выбор хендлеров. Этот подход даёт более понятную семантику и позволяет избежать многих проблем с динамическим выбором хендлеров. Кроме того, во многих библиотеках на Haskell для того, чтобы иметь в стеке эффекты одного типа, используется специальный эффект `Labelled`, которые дают статические метки эффектам. В случае Flow хотим сделать этот эффект бессмысленным и ввести лексические метки эффектам.

## Наследование эффектов

Одна из проблем практического применения эффектов, это сложность их разделения для последующей композиции. В тех же библиотеках на Haskell есть чёткое разграничение между одним эффектом и строкой эффектов. В Flow хотим сделать этот процесс более простым и понятным. Для этого вводится синтаксис наследования эффектов, такой же как в случае trait'ов. То есть фактически сабтайпинга для эффектов не предполагается, вместо этого используется entailment (следование) между эффектами.

## Эффекты в регионах

Все эффекты неявно имеют параметр региона, который задаёт то, в каком регионе эффект может быть исполнен. Кроме того, при зависимости хендлера от другого эффекта, этот эффект наследует регионы этого эффекта.

## Синтаксис эффектов

### Синтаксис интерпретации эффектов

Для интерпретации эффектов есть синтаксис with, который позволяет интерпретировать эффекты в рамках вызова функции или блока кода.

Для блока кода есть синтаксис with:
```rust
with {
  let Reader<R> = reader_handle(env); // ввод нового эффекта происходит через let
  let state: State<S> = state_handle(initial); // так же можно задать label для нового интерпретированного эффекта, тип эффекта задаётся через : и может быть опущен, в таком случае он будет выведен из типа выражения справа от =

  // Ниже синтаксис для замены эффектов для всех вызовов ниже по стеку
  Reader<R> = reader_handle(env);
  state = state_handle(initial);

  // так же в этом блоке возможно задать новое имя для эффекта, важно, что хоть оно и происходит через let, но это не ввод нового эффекта, а лишь добавление нового имени для эффекта, которое будет доступно в текущем блоке кода
  let reader = Reader<R>;
  let state1 = state;

  // так же возможно интерпретировать сразу несколько эффектов, для этого эффекты перечисляются через запятую, а справа от = должен быть handle интерпретирующий соответствующие эффекты
  let Reader<R>, State<S> = reader_state_handle(env, initial);
  let reader, state2 = reader_state_handle(env, initial);
  let reader1: Reader<R>, state2: State<S> = reader_state_handle(env, initial);
  reader1, state2 = reader_state_handle(env, initial); // замена нескольких эффектов одновременно одним handle'ом
} in {
  // ...
}
```

Синтаксис with для вызова функции:
```rust
f() with {
  // интерпретация эффекта Reader<R> для функции f()
  // вводит новый эффект Reader<R>, который будет доступен в функции f()
  // reader_handle(env) - это функция, возвращает хендлер для эффекта Reader<R>
  Reader<R> = reader_handle(env),

  // то же самое, но для labelled эффекта state в f()
  state = state_handle(initial),

  // или можно передать уже интерпретированные эффекты доступные в лексическом контексте
  Reader<R> = r, // r - это label эффекта Reader<R> в текущем лексическом контексте
  state = State<S>, // State<S> служит для указание на эффект State<S> в текущем лексическом контексте
};

// Кроме этого эффекты могут быть заданы в виде "кортежа", тогда для определения эффекта, который должен быть связан будет использоваться порядок эффектов в типе функции
f() with (state, Reader<R>)
```
Синтаксис эффекта для вызова функции ограничен только вводом новых эффектов и передачей уже интерпретированных эффектов доступных в лексическом контексте, замена эффектов при вызове функции не поддерживается. Фактически синтаксис ввода новых эффектов для вызова функции является синтаксическим сахаром над with блоком.

#### Синтаксис in для указания зависимостей handle эффекта
Так как handle могут использовать другие эффекты для интерпретации вводимых ими эффектов, то нужен синтаксис для указания зависимостей handle эффекта. Для этого существует синтаксис in, он доступен в блоках with после выражения возвращающего handle эффекта.
```rust
with {
  let SomeEffect = some_effect_handle() in {
    // здесь синтаксис аналогичен синтаксису with для вызова функции за одним исключением:
    // handle эффекта не может зависеть от нескольких эффектов с одним типом и в целом в типе handle отсутствуют label эффектов, соответственно в этом блоке in в lhs может быть указан только тип эффекта
    Reader<R> = reader_handle(env);
    State<S> = state;
  };
} in {
  // some code
}
```

### Синтаксис хендлеров эффектов

```rust
// мультихендлер для эффектов State и Writer
handle State<S>, Writer<W> in @['r] returning <Y> (Y, S, W) {
  let mut state = 0;
  let mut writer = Monoid::empty();

  op get() -> S { state }
  op put(s: S) { state = s }

  op tell(w: W) { writer ++= w }
  op listen<X, R>(sub: fn() -> @R X) -> @R (X, W) {
    let parent = writer;
    writer = Monoid::empty();
    let x = sub();
    let local = writer;
    writer = parent ++ local;
    (x, local)
  }

  op censor<X, R>(sub: fn() -> @R X, f: fn(W) -> W) -> @R X {
    let parent = writer;
    writer = Monoid::empty();
    let x = sub();
    let local = writer;
    writer = parent ++ f(local);
    x
  }

  returning (x: X) {
    (x, state, writer)
  }
}
```

### Примеры

#### Простой эффект State

Объявление эффекта в Flow `State` выглядит следующим образом:
```rust
pub effect State<S> {
  pub op get() -> S
  pub op put(s: S)
}
```

Тип хендлера для эффекта `State` выглядит следующим образом:
```rust
Handle<
  @[State<'s, S>], // эффекты, которые хендлер вводит в скоуп
  @['s], // эффекты, которые хендлер использует для интерпретации вводимых эффектов
  <X> (X, S), // тип результата хендлера
>;
```

Определение эффекта в Flow `State` выглядит следующим образом:
```rust
fn state_handle<'s, S>(initial: S) -> Handle<@[State<'s, S>], @['s], <X> (X, S)> {
  handle State<'s, S> in @['s] returning <Y> (Y, S) {
    let mut state = initial;

    op get() -> S {
      state
    }

    op put(s: S) {
      state = s;
    }

    returning (y: Y) -> (Y, S) {
      (y, state)
    }
  }
}
```

Интерпретация эффекта в Flow `State` выглядит следующим образом:
```rust
fn main() -> @[IO] () {
  println!("{}", f() with { s = state_handle(0) });
}

fn f() -> @[s: State<i32>] i32 {
  let x = s::get();
  s::put(x + 1);
  s::get()
}
```

#### Простой scoped эффект Reader

Объявление эффекта в Flow `Reader` выглядит следующим образом:
```rust
pub effect Reader<R> {
  pub op ask() -> R
  pub op local<X, Es>(f: fn(R) -> R, action: fn() -> @[Self, ..Es] X) -> @[Self, ..Es] X
  // Es - эффекты которые используются в action.
  // Здесь явно видна разница между операциями в эффектах и функциями в Flow.
  // Операции в эффектах могут неявно захватывать текущий effectful контекст и использовать его для выполнения.
}
```

Тип хендлера для эффекта `Reader` выглядит следующим образом:
```rust
Handle<
  @[Reader<R>],
  @[],
  <X> X
>
```

Определение эффекта в Flow `Reader` выглядит следующим образом:
```rust
fn reader_handle<R>(env: R) -> Handle<@[Reader<R>], @[], <X> X> {
  handle Reader<R> { // тут мы опускаем in и returning, ибо они содержат стандартные значения
    op ask() -> R {
      env
    }

    op local<X, Es>(
      f: fn(R) -> R,
      action: fn() -> @[Self, ..Es] X
    ) -> @[Self, ..Es] X {
      let newEnv = f(env);
      action() with { self = reader_handle(newEnv) }
    }
  }
}
```

#### FileSystem эффект с абстрактным типом файл handle'а

Объявление эффекта в Flow `FileSystem` выглядит следующим образом:
```rust
pub effect FileSystem {
  pub type FileHandle where Read<FileHandle, @[Self]>, Write<FileHandle, @[Self]>;
  pub op open(path: String) -> FileHandle;
  pub op close(handle: FileHandle)
  ... // операции для работы с handle
}
```

Тип хендлера для эффекта `FileSystem` выглядит следующим образом:
```rust
Handle<
  @[FileSystem],
  @[IO],
  <X> X
>
```

Определение эффекта в Flow `FileSystem` выглядит следующим образом:
```rust
fn io_file_system_handle<'r>() -> Handle<@[FileSystem<'r>], @[IO], <X> X> {
  handle FileSystem<'r> {
    type FileHandle<'r1 <: 'r> = std::io::Handle<'r1>;

    op open<'r1 <: 'r>(path: String) -> FileHandle<'r1> {
      std::io::open_file(path)
    }

    op close<'r1 <: 'r>(handle: FileHandle<'r1>) {
      handle.close();
    }

    ... // операции для работы с handle
  }
}
```
