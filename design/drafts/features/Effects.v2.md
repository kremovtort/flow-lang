# Эффекты

Для контроля сайд эффектов и в качестве основного инструмента для инверсии контроля в Flow используются эффекты. Во Flow как языке программирования, фокус идёт на практическом применении эффектов, а не на теоретическом исследовании их возможностей. В связи с этим принимаются решения ниже.

## Какие эффекты поддерживаются

Существуют несколько способов категоризировать эффекты.

1. Первый способ категоризации эффектов:
  - algebraic effects
  - high-order effects:
    - scoped effects
    - parallel effects
    - latent effects

2. Второй способ:
  - single-shot
  - multi-shot

Приоритетна для Flow поддержка ((algebraic + scoped effects) * one-shot effects). Поддержка этого набора эффектов позволяет реализовать подавляющее большинство практически полезных эффектов. Так же она не требует дополнительных механизмов в рантайме для их поддержки, например, delimited continuations.

## Выбор хендлеров для эффектов

В различных языках программирования и библиотеках эффектов используются различные механизмы для выбора хендлеров для эффектов. Базово их можно разделить на два типа: динамический и лексический.

### Динамический выбор хендлеров

Динамический выбор хендлеров заключается в том, что хендлер выбирается в рантайме, в зависимости от контекста выполнения. Этот подход позволяет реализовать очень гибкие и мощные эффекты, но он также требует дополнительных механизмов в рантайме для их поддержки, например, delimited continuations.

### Лексический выбор хендлеров

Лексический выбор хендлеров заключается в том, что хендлер выбирается в лексическом контексте, в зависимости от контекста выполнения. Примерно это работает так: есть стек эффектов, и когда мы попадаем в область действия эффекта, мы выбираем ближайший хендлер соответствующего типа для этого эффекта из стека.

### Выбор хендлеров для эффектов в Flow

В Flow используется лексический выбор хендлеров. Этот подход даёт более понятную семантику и позволяет избежать многих проблем с динамическим выбором хендлеров. Кроме того, во многих библиотеках на Haskell для того, чтобы иметь в стеке эффекты одного типа, используется специальный эффект `Labelled`, которые дают статические метки эффектам. В случае Flow хотим сделать этот эффект бессмысленным и ввести лексические метки эффектам.

## Наследование эффектов

Одна из проблем практического применения эффектов, это сложность их разделения для последующей композиции. В тех же библиотеках на Haskell есть чёткое разграничение между одним эффектом и строкой эффектов. В Flow хотим сделать этот процесс более простым и понятным. Для этого вводится синтаксис наследования эффектов, такой же как в случае trait'ов. То есть фактически сабтайпинга для эффектов не предполагается, вместо этого используется entailment (следование) между эффектами.

## Эффекты в регионах

Все эффекты неявно имеют параметр региона, который задаёт то, в каком регионе эффект может быть исполнен. Кроме того, при зависимости хендлера от другого эффекта, этот эффект наследует регионы этого эффекта.

## Синтаксис эффектов

### Синтаксис интерпретации эффектов

```rust
// интерпретация эффекта при вызове функции
f() with { let Reader<R> = reader_handle(env) }; // для ввода нового эффекта используется ключевое слово let

// интерпретация эффекта для блока кода
let res = with { let State<S> = state_handle(initial) } in {
  let x = State::get();
  State::put(x + 1);
  State::get()
};

// замена эффекта при вызове функции
f() with { Reader<R> = reader_handle(env) }; // без let заменяет текущий эффект Reader<R> на readerHandle(env) для всех вызовов ниже по стеку

// замена эффекта для блока кода
with { State<S> = state_handle(initial) } in {
  let x = State::get();
  State::put(x + 1);
  State::get()
}; // заменяет текущий эффект Reader<R> на readerHandle(env) для всех вызовов ниже по стеку

// интерпретация нескольких эффектов при вызове функции
f() with {
  let Reader<R> = reader_handle(env);
  let State<S>, Writer<S> = state_writer_handle(initial); // интерпретация нескольких эффектов одним хендлером
  Writer<S> = writer_replace_handle(); // какой-то хендлер, который заменяет текущий Writer<S> на writer_replace_handle() для всех вызовов ниже по стеку
} // для блока кода синтаксис аналогичен синтаксису при вызове функции, меняется только позиция with/in

// labelled эффекты
f() with { let r = reader_handle(env) }; // здесь интерпретируется эффект labelled как r в функции f()

// labelled эффекты для блока кода
let res = with { let r = reader_handle(env) } in {
  let x = r::ask();
  r::local(|y| y + 1, || {
    r::ask()
  })
};

// короткий синтаксис для интерпретации эффектов: можно писать let перед выражением возвращающим хендл эффекта для того, чтобы ввести в скоуп новый эффект. Замена(impose) эффекта при этом обязательно должна быть записана явно через =
f() with { let reader_handle(env) };

// короткий синтаксис для интерпретации эффектов для блока кода
with { let reader_handle(env) } in {
  let x = Reader::ask();
  Reader::local(|y| y + 1, || {
    Reader::ask()
  })
}
```

### Синтаксис хендлеров эффектов

```rust
// синтаксис хендлера для эффекта State
handle State<S> in @['r] returning<Y> (Y, S) {
  let mut state = 0; // внутри хендлера эффекта допустимо вводить локальные переменные
  op get() -> S { state }
  op put(s: S) { state = s }
  returning (y: Y) -> (Y, S) { (y, state) }
}

// мультихендлер для эффектов State и Writer
handle State<S>, Writer<W> in @['r] returning<Y> (Y, S, W) {
  let mut state = 0;
  let mut writer = Monoid::empty();

  op get() -> S { state }
  op put(s: S) { state = s }

  op tell(w: W) { writer ++= w }
  op listen<X, R>(sub: fn() -> @R X) -> @R (X, W) {
    let parent = writer;
    writer = Monoid::empty();
    let x = sub();
    let local = writer;
    writer = parent ++ local;
    (x, local)
  }

  op censor<X, R>(sub: fn() -> @R X, f: fn(W) -> W) -> @R X {
    let parent = writer;
    writer = Monoid::empty();
    let x = sub();
    let local = writer;
    writer = parent ++ f(local);
    x
  }

  returning (y: Y) -> (Y, S, W) { (y, state, writer) }
}
```

### Примеры

#### Простой эффект State

Объявление эффекта в Flow `State` выглядит следующим образом:
```rust
pub effect State<S> {
  pub op get() -> S
  pub op put(s: S)
}
```

Тип хендлера для эффекта `State` выглядит следующим образом:
```rust
Handle<
  @[State<'s, S>], // эффекты, которые хендлер вводит в скоуп
  @['s], // эффекты, которые хендлер использует для интерпретации вводимых эффектов
  <X> (X, S), // тип результата хендлера
>;
```

Определение эффекта в Flow `State` выглядит следующим образом:
```rust
fn stateHandle<'s, S>(initial: S) -> Handle<@[State<'s, S>], @['s], <X> (X, S)> {
  handle State<'s, S> in @['s] returning<Y> (Y, S) {
    let mut state = initial;

    op get() -> S {
      state
    }

    op put(s: S) {
      state = s;
    }

    returning (y: Y) -> (Y, S) {
      (y, state)
    }
  }
}
```

Интерпретация эффекта в Flow `State` выглядит следующим образом:
```rust
fn main() -> @[IO] () {
  println!("{}", f() with { let s = stateHandle(0) });
}

fn f() -> @[s: State<i32>] i32 {
  let x = s::get();
  s::put(x + 1);
  s::get()
}
```

#### Простой scoped эффект Reader

Объявление эффекта в Flow `Reader` выглядит следующим образом:
```rust
pub effect Reader<R> {
  pub op ask() -> R
  pub op local<X, Es>(f: fn(R) -> R, action: fn() -> @[Self, ..Es] X) -> @[Self, ..Es] X
  // Es - эффекты которые используются в action.
  // Здесь явно видна разница между операциями в эффектах и функциями в Flow.
  // Операции в эффектах могут неявно захватывать текущий effectful контекст и использовать его для выполнения.
}
```

Тип хендлера для эффекта `Reader` выглядит следующим образом:
```rust
Handle<
  @[Reader<R>],
  @[],
  <X> X
>
```

Определение эффекта в Flow `Reader` выглядит следующим образом:
```rust
fn reader_handle<R>(env: R) -> Handle<@[Reader<R>], @[], <X> X> {
  handle Reader<R> { // тут мы опускаем in и returning, ибо они содержат стандартные значения
    op ask() -> R {
      env
    }

    op local<X, Es>(f: fn(R) -> R, action: fn() -> @[Self, ..Es] X) -> @[Self, ..Es] X {
      let newEnv = f(env);
      action() with { self = reader_handle(newEnv) }
    }
  }
}
```

#### FileSystem эффект с абстрактным типом файл handle'а

Объявление эффекта в Flow `FileSystem` выглядит следующим образом:
```rust
pub effect FileSystem {
  pub type FileHandle where Read<FileHandle, @[Self]>, Write<FileHandle, @[Self]>;
  pub op open(path: String) -> FileHandle;
  pub op close(handle: FileHandle)
  ... // операции для работы с handle
}
```

Тип хендлера для эффекта `FileSystem` выглядит следующим образом:
```rust
Handle<
  @[FileSystem],
  @[IO],
  <X> X
>
```

Определение эффекта в Flow `FileSystem` выглядит следующим образом:
```rust
fn io_file_system_handle<'r>() -> Handle<@[FileSystem<'r>], @[IO], <X> X> {
  handle FileSystem<'r> {
    type FileHandle = std::io::Handle<'r>;

    op open(path: String) -> FileHandle {
      std::io::open_file(path)
    }

    op close(handle: FileHandle) {
      handle.close();
    }

    ... // операции для работы с handle
  }
}
```
