# Regions

Регионы - фича для обеспечения безопасного доступа к объектам в зависимости от того, в каком контексте они используются.

## Мотивация
При имплементации различных эффектов зачастую возникает проблема с обеспечением безопасности доступа к различным эффектам и объектам в зависимости от того, в каком контексте они используются. Чтобы решить эту проблему, я решил ~~скрестить ежа с ужом~~ помимо эффектов ввести в язык понятие регионов.

Вот примеры когда это может быть полезно:
- Предотвращение race conditions за счёт проверки на этапе компиляции, что объект не защищённый локом из одного потока не используется в другом потоке.
- Предотвращение утечек ресурсов за счёт проверки на этапе компиляции, что объект не используется после того, как он был закрыт.
- Предотвращение доступа к внешнему состоянию изнутри чистых функций, с возможностью внутри чистых функций оперировать внутренним мутабельным состоянием.

## Что такое регион?
Регион это контекст в рамках которого можно работать с определённой группой объектов. Самый очевидный пример региона - это поток. В рамках потока можно работать с объектами, которые принадлежат этому потоку, а для общения с другими потоками должны использоваться примитивы синхронизации. Регионы могут быть вложенными друг в друга, например, внутри потока можно создать регион в рамках которого будет доступен какой-то ресурс, но вне этого региона доступ к этому ресурсу будет запрещён. Регионы могут быть отсоединены друг от друга, например, для корректной работы STM, внутри функции выполняющей атомарную транзакцию не должно быть доступа к внешнему состоянию, с помощью регионов этого можно достичь введя в рамках функции запускающей транзакцию отедельный регион, из которого внешнее состояние не будет доступно.

## Синтаксис регионов
Регионы задаются через префикс `'`:
```rust
'r : Region
```
Регионы могут быть созданы при входе в блок кода:
```rust
{ 'r =>
  ... // код в рамках региона 'r
}
```
Регионы созданные таким образом автоматически являются вложенными во внешний регион:
```rust
{ 'r1 =>
  { 'r2 => ...
  } // 'r2 вложен в 'r1
} // 'r1 закрывается
```
Типы и функции могут быть параметризованы регионами:
```rust
let x: &'r i32 = ...; // ссылка в регион 'r, доступна для чтения и изменения только внутри 'r и вложенных в него регионов
let y: &'r mut i32 = ...; // мутабельная ссылка в регион 'r, доступна для чтения и изменения только внутри 'r и вложенных в него регионов
foo<'r>(x, y); // функция принимающая ссылку в регион 'r и мутабельную ссылку в регион 'r
foo(x, y); // параметр типа региона выведется сам
```
Таким образом функция параметризируется регионом:
```rust
fn foo<'r>(x: &'r i32, y: &'r mut i32) -> @['r] () { // 'r в списке эффектов означает, что функция может использовать объекты из региона 'r
  ...
}
```
Типы данных могут быть параметризованы регионами:
```rust
struct Foo<'r> {
  x: &'r i32,
  y: &'r mut i32,
}

struct Bar<'r> { // здесь параметр региона фантомный, т.к. он не используется в определении типа, но может быть использован в функциях принимающих этот тип
  x: X,
  y: Y,
}
```
Существует специальный регион `'const`, который служит для ссылок на неизменяемые объекты. По умолчанию переменная заданная через `let` является иммутабельной и взятие ссылки на неё даёт ссылку в регион `'const`.
```rust
let x = 10;
let y: &'const i32 = &x; // y в регион 'const, т.к. x иммутабельно
```
Ссылки в регион `'const` не могут быть иммутабельными. Попытка взять мутабельную ссылку на объект в регион `'const` приведёт к ошибке компиляции.
```rust
let x = 10;
let y: &'const mut i32 = &mut x; // ошибка компиляции, y не может быть мутабельной ссылкой в регион 'const
```
При этом регион `'const` унифицируется с любым другим регионом, т.е. ссылки в регион `'const` можно использовать в любом регионе. Попытка унифицировать мутабельную ссылку из региона `'const` с другим регионом приведёт к ошибке компиляции.
```rust
let x = 10;
let y: &'const i32 = &x; // y в регион 'const, т.к. x иммутабельно
let z: &'r i32 = y; // z в регион 'r, т.к. y унифицируется с 'r
```

## Алгебра регионов
`:<` — отношение вложенности регионов. `'r1 <: 'r2` означает, что `'r1` вложен (живет не дольше) в `'r2`.

1. Рефлексивность
  - `forall 'r . 'r :< 'r`
2. Транзитивность
  - `forall 'r1, 'r2, 'r3 . 'r1 :< 'r2 && 'r2 :< 'r3 => 'r1 :< 'r3`
3. Антисимметричность
  - `forall 'r1, 'r2 . 'r1 :< 'r2 && 'r2 :< 'r1 => 'r1 == 'r2`
4. Все регионы вложены в `'const`
  - `forall 'r . 'r :< 'const`
5. Ковариантность по регионам (вариантность)
  - Ссылки:
    - `&'r T` — ковариантно по `'r` и по `T`.
      - `forall 'r1, 'r2, T<_> : Type . 'r1 :< 'r2 => &'r1 T <: &'r2 T`
    - `&'r mut T` — ковариантно по `'r` и по `T`.
      - `forall 'r1, 'r2, T<_> : Type . 'r1 :< 'r2 => &'r1 mut T <: &'r2 mut T`
  - Функции:
    - ковариантны по результату и контравариантны по аргументам.
      - `forall 'r1, 'r2, T<_> : Type . 'r1 :< 'r2 => (fn(&'r2 T) -> T) <: (fn(&'r1 T) -> T)`
      - `forall 'r1, 'r2, T<_> : Type . 'r1 :< 'r2 => (fn(T) -> &'r1 T) <: (fn(T) -> &'r2 T)`
  - Суммы/записи/кортежи/пользовательские типы:
    - вариантность выводится структурно из компонент.
  - Следствие (сужение региона):
    - если `'r1 :< 'r2` и тип `T` ковариантен по параметру региона (вариантность `T` выведена структурно), то `T<'r1> <: T<'r2>`
6. Регион `'const` не может содержать `mut` ссылки.

Примечание: доступ к объектам регионов и их эффектная семантика описаны в разделе «Эффекты регионов» ниже.

## Эффекты регионов
- Вводятся эффекты доступа:
  - `Region::Read<'r>`
  - `Region::Write<'r>`
  - Сахар: `Region<'r> = Region::Read<'r> + Region::Write<'r>`
- Любой доступ требует эффекта:
  - разыменование `&'r T` — требует `Region::Read<'r>`
  - запись через `&'r mut T` — требует `Region::Write<'r>`
- «Запись влечет чтение»:
  - `forall 'r . Region::Write<'r> => Region::Read<'r>`
- Совместимость с вложенностью регионов:
  - `forall 'r1, 'r2 . 'r1 :< 'r2 => Region::Read<'r1> => Region::Read<'r2>`
  - `forall 'r1, 'r2 . 'r1 :< 'r2 => Region::Write<'r1> => Region::Write<'r2>`

Подтипирование функций с эффектами и требованиями:
- Обозначим через `E` — множество эффектов, `C` — множество трейтов/ограничений.
- Тогда верно включение (чем меньше требуется, тем шире тип):
  - при `E1 ⊆ E2`, `C1 ⊆ C2`, `Arg2 <: Arg1`, `Res1 <: Res2` имеем
  - `(Arg1 ->_{E1,C1} Res1) <: (Arg2 ->_{E2,C2} Res2)`

## Глубокая немутируемость типов
- Авто-трейт: `NonMut<X<_..._>>`.
- Интуиция: `NonMut<<'i> T<'i, …>>` означает, что для любого `'i` тип `T<'i, …>` не содержит `&'i mut _` на любом уровне (глубоко).
- Структурные правила:
  - Базовые типы — истина.
  - Суммы/записи/кортежи — конъюнкция по компонентам.
  - Ссылки: `&'s U` — истина, если `NonMut<<'i> U>`; `&'s mut U` — ложь.
  - Параметризованные типы: если определение доступно, `NonMut` выводится структурно; иначе требуется явный констрейнт `NonMut<X<_..._>>`.
  - Функциональные значения: допустимы в константных регионах только если их латентные эффекты не содержат `Region::Write<'r>` после подстановки регионов назначения.

## Оператор alloc
Синтаксис:
```rust
alloc 'r { 'i =>
  // тело
}
// либо с выводом типов:
alloc {
  // тело
}
```
Правила:
- `'i` — свежий регион, не вложенный ни в какой другой (кроме рефлексивности и общего `'<: 'const`).
- Внутри тела доступны эффекты всех внешних регионов и эффекты для `'i` (чтение/запись возможны при наличии соответствующих `Region::Read/Write`).
- Если тело типизируется как `e : T<'i, …>`, то весь блок имеет тип `T<'r, …>` (на выходе применяется подстановка `'i := 'r`).
- Если целевой регион константный (т.е. не `NonConst`), то дополнительно проверяется:
  - `NonMut<<'α> T<'α, …>>`,
  - и что латентные эффекты всех значений в результате не содержат `Region::Write<'r>` после подстановки `'i := 'r`.
- Разрешено возвращать значения, содержащие ссылки на внешние регионы (например, `Vec<'r, &'r1 U>`).

Пример:
```rust
forall 'r .
{ 'r1 =>
  let mut x: i32 = 10;
  let xRef: &'r1 i32 = &x;
  let v: Vec<'r, i32> =
    alloc in 'r { 'i =>
      let mut tmp: Vec<'i, i32> = Vec::new();
      tmp.push(1);
      tmp.push(2);
      tmp.push(*xRef);
      tmp // после выхода: Vec<'r, i32>
    };
}
```

## Регион 'global
Также существует специальный регион `'global`, это особый регион, который считается вложенным в любой другой регион. Все операции выполняемые в этом регионе считаются unsafe и могут быть выполнены только в `unsafe` блоке или функции.
4. Вложенность 'global в любой регион – `forall 'r . 'global :< 'r`

## Отделение регионов
Выделение отдельного региона и стирание информации о вложенности его в другие регионы осуществляется c помощью универсального квантора. Например, сигнатура функции `atomically`, которая запускает атомарную транзакцию в STM, может быть записана так:
```rust
fn atomically<'r>(f: fn() -> @[STM] X) -> @['r, Sync] X {
  ...
}
```
В этом примере `atomically` принимает функцию `f`, которая не имеет доступа к региону `'r`. Таким образом, регион в котором работает `f` никак не связан с регионом `'r` и `f` не имеет доступа к внешнему состоянию.
