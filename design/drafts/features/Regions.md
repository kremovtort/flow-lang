# Regions

Регионы - фича для обеспечения безопасного доступа к объектам в зависимости от того, в каком контексте они используются.

## Мотивация
При имплементации различных эффектов зачастую возникает проблема с обеспечением безопасности доступа к различным эффектам и объектам в зависимости от того, в каком контексте они используются. Чтобы решить эту проблему, я решил ~~скрестить ежа с ужом~~ помимо эффектов ввести в язык понятие регионов.

Вот примеры когда это может быть полезно:
- Предотвращение race conditions за счёт проверки на этапе компиляции, что объект не защищённый локом из одного потока не используется в другом потоке.
- Предотвращение утечек ресурсов за счёт проверки на этапе компиляции, что объект не используется после того, как он был закрыт.
- Предотвращение доступа к внешнему состоянию изнутри чистых функций, с возможностью внутри чистых функций оперировать внутренним мутабельным состоянием.

## Что такое регион?
Регион это контекст в рамках которого можно работать с определённой группой объектов. Самый очевидный пример региона - это поток. В рамках потока можно работать с объектами, которые принадлежат этому потоку, а для общения с другими потоками должны использоваться примитивы синхронизации. Регионы могут быть вложенными друг в друга, например, внутри потока можно создать регион в рамках которого будет доступен какой-то ресурс, но вне этого региона доступ к этому ресурсу будет запрещён. Регионы могут быть отсоединены друг от друга, например, для корректной работы STM, внутри функции выполняющей атомарную транзакцию не должно быть доступа к внешнему состоянию, с помощью регионов этого можно достичь введя в рамках функции запускающей транзакцию отедельный регион, из которого внешнее состояние не будет доступно.

## Синтаксис регионов
Регионы задаются через префикс `'`:
```rust
'r : Region
```
Регионы могут быть созданы при входе в блок кода:
```rust
{ 'r =>
  ... // код в рамках региона 'r
}
```
Регионы созданные таким образом автоматически являются вложенными во внешний регион:
```rust
{ 'r1 =>
  { 'r2 => ...
  } // 'r2 вложен в 'r1
} // 'r1 закрывается
```
Типы и функции могут быть параметризованы регионами:
```rust
let x: &'r i32 = ...; // ссылка в регион 'r, доступна для чтения и изменения только внутри 'r и вложенных в него регионов
let y: &'r mut i32 = ...; // мутабельная ссылка в регион 'r, доступна для чтения и изменения только внутри 'r и вложенных в него регионов
foo<'r>(x, y); // функция принимающая ссылку в регион 'r и мутабельную ссылку в регион 'r
foo(x, y); // параметр типа региона выведется сам
```
Таким образом функция параметризируется регионом:
```rust
fn foo<'r>(x: &'r i32, y: &'r mut i32) -> @['r] () { // 'r в списке эффектов означает, что функция может использовать объекты из региона 'r
  ...
}
```
Типы данных могут быть параметризованы регионами:
```rust
struct Foo<'r> {
  x: &'r i32,
  y: &'r mut i32,
}

struct Bar<'r> { // здесь параметр региона фантомный, т.к. он не используется в определении типа, но может быть использован в функциях принимающих этот тип
  x: X,
  y: Y,
}
```
Существует специальный регион `'const`, который служит для ссылок на неизменяемые объекты. По умолчанию переменная заданная через `let` является иммутабельной и взятие ссылки на неё даёт ссылку в регион `'const`.
```rust
let x = 10;
let y: &'const i32 = &x; // y в регион 'const, т.к. x иммутабельно
```
Ссылки в регион `'const` не могут быть иммутабельными. Попытка взять мутабельную ссылку на объект в регион `'const` приведёт к ошибке компиляции.
```rust
let x = 10;
let y: &'const mut i32 = &mut x; // ошибка компиляции, y не может быть мутабельной ссылкой в регион 'const
```
При этом регион `'const` унифицируется с любым другим регионом, т.е. ссылки в регион `'const` можно использовать в любом регионе. Попытка унифицировать мутабельную ссылку из региона `'const` с другим регионом приведёт к ошибке компиляции.
```rust
let x = 10;
let y: &'const i32 = &x; // y в регион 'const, т.к. x иммутабельно
let z: &'r i32 = y; // z в регион 'r, т.к. y унифицируется с 'r
```
Когда регион `'r` умирает и при этом он является отделённым регионом, то есть происходит выход из блока кода, в котором он был создан, регион унифицируется с любым другим регионом, но только с одним регионом. Если же регион `'r` является вложенным по отношению к другому региону, то он унифицируется с этим регионом, но не с другими регионами.
```rust
{ 'r1 =>
  let v1: Vec<'const, i32> = { 'r2 => // ни разу не происходит обращение к 'r1, из чего мы выводим, что 'r2 - отдельный регион
    let mut v = Vec::new();
    v.push(1);
    v.push(2);
    v
  }; // 'r2 умирает

  let v2: Vec<'r1, i32> = { 'r2 =>
    let mut v = Vec::new();
    v.push(1);
    v.push(2);
    v
  }; // 'r2 умирает

  let (v3: Vec<'r1, i32>, v4: Vec<'const, i32>) = { 'r2 => // ошибка компиляции, r2 не может быть унифицирован одновременно с 'const и 'r1
    let mut vv1 = Vec::new();
    let mut vv2 = Vec::new();
    vv1.push(1);
    vv1.push(2);
    vv2.push(3);
    vv2.push(4);
    (vv1, vv2)
  }; // 'r2 умирает

  let v5: Vec<'const, i32> = { 'r2 => // ошибка компиляции, 'r2 не может быть унифицирован с 'const, так как 'r2 вложен в 'r1
    let mut v = v2;
    v.push(1); // происходит обращение к 'r1, из чего мы выводим, что 'r2 вложен в 'r1
    v.push(2);
    v
  }; // 'r2 умирает, унификация может произойти только с текущим регионом 'r1
} // 'r1 умирает
```

## Алгебра регионов
`:<` - отношение вложенности регионов. `'r1 <: 'r2` означает, что `'r1` вложен в `'r2`. `Region<'r>` - эффект, который позволяет работать с ссылками в регион `'r`.
1. Рефлексифность
  - `forall 'r . 'r :< 'r`
2. Транзитивность
  - `forall 'r1, 'r2, 'r3 . 'r1 :< 'r2 && 'r2 :< 'r3 => 'r1 :< 'r3`
3. Антисимметричность
  - `forall 'r1, 'r2 . 'r1 :< 'r2 && 'r2 :< 'r1 => 'r1 == 'r2`
4. Все регионы вложены в 'const
  - `forall 'r . 'r :< 'const`
5. Объекты из внешнего региона унифицируются с объектами из вложенного региона:
  - `forall 'r1, 'r2, T<_> : Type . 'r1 :< 'r2 => T<'r2> => T<'r1>`
6. Из вложенного региона можно работать с объектами из внешнего региона:
  - `forall 'r1, 'r2 . 'r1 :< 'r2 => Region<'r1> => Region<'r2>`
7. При выходе из региона, который не является вложеный ни в какой другой регион, кроме `'const`, регион может быть унифицирован с любым другим регионом 1 раз.
  - `forall 'r, 'rr, T<_> : Type . !(exists 'r1 . 'r1 != 'const && 'r :< 'r1) && isDead('r) => (T<'r> => T<'rr>) % 1`
8. Регион `'const` не может содержать `mut` ссылки.
  - `!(exist &'const mut T)`

7 и 8 правила противоречат друг другу:
```rust
struct Foo<'r> {
  bar: &'r mut i32,
}

{ 'r1 =>
  let foo: Foo<'const> = { 'r2 => // 'r2 не вложен в 'r, так как в 'r2 нет обращений к 'r
    let mut bar = 10;
    Foo<'r2> { bar = &'r2 mut bar } // получаем мутабельную ссылку в регион 'const
  };
}
```

## Регион 'global
Также существует специальный регион `'global`, это особый регион, который считается вложенным в любой другой регион. Все операции выполняемые в этом регионе считаются unsafe и могут быть выполнены только в `unsafe` блоке или функции.
4. Вложенность 'global в любой регион – `forall 'r . 'global :< 'r`

## Отделение регионов
Выделение отдельного региона и стирание информации о вложенности его в другие регионы осуществляется c помощью универсального квантора. Например, сигнатура функции `atomically`, которая запускает атомарную транзакцию в STM, может быть записана так:
```rust
fn atomically<'r, X<_>>(f: <'i> fn() -> @['i, STM] X<'i>) -> @[Sync] X<'r> {
  ...
}
```
В этом примере `atomically` принимает функцию `f` параметризированную неизвестным регионом `'i`. О том, каким образом этот регион связан с регионом из которого вызывается `atomically` `f` ничего не знает. В связи с этим регион `'i` является отделенным от региона из которого вызывается `atomically`. Но так как известно, что после выполнения `f` регион `'i` умрёт, мы можем параметризировать `atomically` любым регионом `'r`.
