Суть – нужно как-то управлять мутабельностью в языке. Самый простой пример зачем это нужно – для работы с `STM`. Для этого нужна система в которой можно определять скоуп мутабельности.

Для начала базовые требования для работы с STM:
- обеспечить возможность читать в STM иммутабельные ссылки **снаружи**
- запретить мутировать изнутри STM мутабельные ссылки **снаружи**
- обеспечить возможность передавать мутабельные ссылки из глобального скоупа, но не читать/мутировать их
Первое, что кажется разумным сделать - это запретить мутации внешних ссылок вне effectful вычислений

```rust
// доступ к внешнему mutability scope
fn sort<'s, A :< Ord>(vec: &'s mut Vec<A>) -> @['s] () {
  vec.sortWith(|a, b| a.cmp(b));
}
// по дефолту скоупы выводится, так что можно сократить до:
fn sort<A :< Ord>(vec: &mut Vec<A>) {
  vec.sortWith(|a, b| a.cmp(b));
}

// доступ к внешнему и внутреннему mutability scope
fn
  withLock<'o, A, X, R>(
    mutex: Mutex<A>,
    f: <'i> fn(&'i mut A) -> @['i, 'o, ..R] X
  ) -> @[Sync, ..R] X {
  ...
}

// доступ только к внутреннему mutability scope
fn atomically<X>(action: <'i> fn() -> @['i, STM] X) -> @[Sync] X {
  ...
}

// при этом когда &mut даункастится до & она сохраняет свой mutability scope,
// это оставляет информацию о том, что эта ссылка может быть мутирована где-то в другом скоупе.
// ссылки на чтение соответственно так же могут быть прочитаны только при из своего scope.
// при этом все немутабельные объекты при получении ссылки на них получают const scope
fn myTransaction(p: &'const Point) -> @[STM] () {
  ...
}
```
